<!DOCTYPE HTML>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <title>Backbone UI</title>

    <!-- JS -->
    <!-- CSS -->

    <script type="text/javascript" src="script.js"></script>
    <script type="text/javascript" src="lib/jsbeautify.js"></script>
    <script type="text/javascript" src="lib/prettify.js"></script>

    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="lib/prettify.css">
    <link href='http://fonts.googleapis.com/css?family=Brawler' rel='stylesheet' type='text/css'>
  </head>

  <body>
    <div class="backbone_heading">
      <div class="container">
        <div class="name">Backbone UI</div>
      </div>
    </div>

    <div class="section">
      <section>
        <h1>Overview</h1>

        <p>
        Backbone UI provides a simple way to represent your Backbone Models and Collections as UI components.  The need to shuffle data in and out of your UI is replaced with simple data binding techniques.  All components are skinnable with CSS, and will render consistently accross browsers.
        </p>
      </section>

      <section>
        <h1>Philosiphy</h1>

        <p>
        This framework is written to embrace the DOM rather than fight it.  You won't see any messy HTML templates or <code>innerHTML</code> references hanging around.  What you will see is heavy use of the <a href="http://joestelmach.github.com/laconic/">laconic</a> library to help ease the pain of DOM manipluation so we can happily stay in the context of writing JavaScript.
        </p>
        <p>
        Not all people will agree with this philosiphy, and not all projects will benefit from embracing it.  This framework facilitates the creation of highly dynamic front-end clients that request only data from the back-end, not markup.  If you have a more traditional application in which your markup is generated before your JavaScript executes, you may still find this framework useful, but keep in mind that it was not designed for such a case.
        </p>
        <p>
        Another major theme you'll encounter is the concept of data binding.  This means that you tell your component which property of the model it's responsible for rendering, and then you forget about shuffling data back and forth.  If the model's value changes, the component will re-render.  If the user changes the value, the model will be updated.  Easy.
        </p>
      </section>

      <section>
        <h1>Dependencies</h1>

        <p>Backbone UI depends on the following libraries:</p>

        <ul>
          <li><a href='http://documentcloud.github.com/backbone/'>Backbone</a></li>
          <li><a href='http://documentcloud.github.com/underscore/'>Underscore</a></li>
          <li><a href='http://jquery.com/'>jQuery</a></li>
          <li><a href='http://joestelmach.github.com/laconic/'>laconic</a></li>
        </ul>

        <p>
          If you'd like to use the calendar or date picker components, than you'll 
          also need a copy of <a href='http://momentjs.com/'>moment.js</a>.
        <p>
      </section>

      <section>
        <h1>Components</h1>
        <p>
        All components inherit from Backbone.View, and each render method will return a reference to the view itself.  Feel free to pass any standard <a href='http://documentcloud.github.com/backbone/#View-constructor'>Backbone.View option</a> when creating these components.
        As a convenience, the underscored version of the component's class name will be added to each component's element.  
        </p>

        <p>
        Components can be broken down into four categories:
        </p>
        <ul>
          <li>Model Bound</li>
          <li>Collection Bound</li>
          <li>Model Bound with Collection Property</li>
          <li>Non-Bound</li>
        </ul>

        <p>
        The following data will be used throughout the examples:
        </p>

        <div class="code">
          <code><pre id="setup_code" class="prettyprint"></pre></code>
        </div>
      </section>

    </div>

    <div id="example_data" style="display:none">
      <a href="#" id="close_example">&times;</a>
      <div class="title">Coffee Model State</div>
      <div id="example_state"></div>
    </div>

    <section class="component_type model_bound">
      <h1>Model-Bound</h1>

      <p>
      Model-Bound components are those that interact directly with one or more properties of a single model.
      </p>

      <!-- MODEL_OPTIONS -->

      <div class="components">
        <!-- MODEL_BOUND -->
      </div>
    </section>

    <section class="component_type model_bound_with_collection">
      <h1>Model-Bound with Collection Property</h1>
      <p>
      These components are similar to regular Model-Bound components, but also include a bound collection of alternatives.  The <code>model</code> and <code>property</code> options are still used to define the selected value, and following additional options describe the collection of alternatives:
      </p>

      <!-- MODEL_COLLECTION_OPTIONS -->

      <div class="options">
      </div>

      <div class="components">
        <!-- MODEL_BOUND_WITH_COLLECTION -->
      </div>
    </section>

    <section class="component_type collection_bound">
      <h1>Collection-Bound</h1>
      <div class="components">
        <!-- COLLECTION_BOUND -->
      </div>
    </section>

    <section class="component_type non_bound">
      <h1>Non-Bound</h1>
      <div class="components">
        <!-- NON_BOUND -->
      </div>
    </section>
  </body>
</html>
